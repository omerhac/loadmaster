name: Build and Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test-ios:
    runs-on: macos-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Cache CocoaPods
      uses: actions/cache@v3
      with:
        path: ios/Pods
        key: ${{ runner.os }}-pods-${{ hashFiles('**/Podfile.lock') }}
        restore-keys: |
          ${{ runner.os }}-pods-
      
    - name: Cache Xcode build
      uses: actions/cache@v3
      with:
        path: ios/build
        key: ${{ runner.os }}-xcode-build-${{ hashFiles('ios/**/*.pbxproj') }}-${{ hashFiles('ios/**/*.swift') }}-${{ hashFiles('ios/**/*.m') }}
        restore-keys: |
          ${{ runner.os }}-xcode-build-
          ${{ runner.os }}-xcode-build-${{ hashFiles('ios/**/*.pbxproj') }}-${{ hashFiles('ios/**/*.swift') }}
      
    - name: Run linter
      run: npm run lint
      
    - name: Run tests
      run: npm test
      
    - name: Install Pod dependencies
      run: |
        cd ios
        pod install
  
    # Build for iPad with landscape orientation
    - name: Build iOS for iPad
      run: |
        xcodebuild -workspace ios/loadmaster.xcworkspace -scheme loadmaster -configuration Release -destination 'platform=iOS Simulator,name=iPad (10th generation)' -derivedDataPath ios/build
    
    - name: Upload iOS build artifact
      uses: actions/upload-artifact@main
      with:
        name: ios-ipad-build
        path: ios/build/Build/Products/Release-iphonesimulator/*.app
        
  build-and-test-windows:
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Install RNW Windows Build Dependencies
      shell: powershell
      run: |
        Set-ExecutionPolicy Unrestricted -Scope Process -Force
        Invoke-WebRequest -UseBasicParsing -Uri 'https://aka.ms/rnw-vs2022-deps.ps1' -OutFile rnw-deps.ps1
        .\\rnw-deps.ps1 -Install -NoPrompt

    - name: Cache Windows build
      uses: actions/cache@v3
      with:
        path: windows/build
        key: ${{ runner.os }}-windows-build-${{ hashFiles('windows/**/*.sln') }}-${{ hashFiles('windows/**/*.cs') }}-${{ hashFiles('windows/**/*.cpp') }}
        restore-keys: |
          ${{ runner.os }}-windows-build-
      
    - name: Run linter
      run: npm run lint
      
    - name: Run tests
      run: npm test
      
    - name: Install react-native-windows
      run: npm install --save-dev react-native-windows@latest

    # Update the Platform Toolset for SQLitePlugin to v143 (Visual Studio 2022)
    - name: Update SQLitePlugin Platform Toolset
      shell: powershell
      run: |
        $projFile = "node_modules\\react-native-sqlite-storage\\platforms\\windows\\SQLitePlugin\\SQLitePlugin.vcxproj"
        if (Test-Path $projFile) {
          (Get-Content $projFile) -replace '<PlatformToolset>v140</PlatformToolset>','<PlatformToolset>v143</PlatformToolset>' -replace '<PlatformToolset>v141</PlatformToolset>','<PlatformToolset>v143</PlatformToolset>' | Set-Content $projFile
          Write-Host "Updated Platform Toolset in SQLitePlugin.vcxproj to v143"
        } else {
          Write-Error "SQLitePlugin.vcxproj not found at expected path"
          exit 1
        }

    # Update the Windows SDK version for SQLitePlugin to one available in the CI environment
    - name: Update SQLite Windows SDK Version
      shell: powershell
      run: |
        $projFile = "node_modules\\react-native-sqlite-storage\\platforms\\windows\\SQLitePlugin\\SQLitePlugin.vcxproj"
        if (Test-Path $projFile) {
          (Get-Content $projFile) -replace '10.0.18362.0','10.0.19041.0' -replace '10.0.16299.0','10.0.19041.0' | Set-Content $projFile
          Write-Host "Updated SQLite Windows SDK version in SQLitePlugin.vcxproj to 10.0.19041.0"
        } else {
          Write-Error "SQLitePlugin.vcxproj not found at expected path"
          exit 1
        }
    # Comprehensive Windows SDK Version Fix - Update all project files to use available SDK
    - name: Fix All Windows SDK Versions
      shell: powershell
      run: |
        Write-Host "Updating Windows SDK versions in all project files..."
        
        # Find all .vcxproj files that might have old SDK versions
        $projectFiles = Get-ChildItem -Path "node_modules" -Filter "*.vcxproj" -Recurse -ErrorAction SilentlyContinue
        $projectFiles += Get-ChildItem -Path "windows" -Filter "*.vcxproj" -Recurse -ErrorAction SilentlyContinue
        
        foreach ($projFile in $projectFiles) {
          Write-Host "Checking project file: $($projFile.FullName)"
          
          # Read the content
          $content = Get-Content $projFile.FullName -Raw
          $originalContent = $content
          
          # Replace various old Windows SDK versions with 10.0.19041.0
          $content = $content -replace '<WindowsTargetPlatformVersion>10\.0\.18362\.0</WindowsTargetPlatformVersion>', '<WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>'
          $content = $content -replace '<WindowsTargetPlatformVersion>10\.0\.17763\.0</WindowsTargetPlatformVersion>', '<WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>'
          $content = $content -replace '<WindowsTargetPlatformVersion>10\.0\.16299\.0</WindowsTargetPlatformVersion>', '<WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>'
          $content = $content -replace '<WindowsTargetPlatformVersion>10\.0\.15063\.0</WindowsTargetPlatformVersion>', '<WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>'
          
          # Also replace in plain text SDK version references
          $content = $content -replace '10\.0\.18362\.0', '10.0.19041.0'
          $content = $content -replace '10\.0\.17763\.0', '10.0.19041.0'
          $content = $content -replace '10\.0\.16299\.0', '10.0.19041.0'
          $content = $content -replace '10\.0\.15063\.0', '10.0.19041.0'
          
          # Write back if changed
          if ($content -ne $originalContent) {
            Set-Content -Path $projFile.FullName -Value $content
            Write-Host "Updated SDK version in: $($projFile.FullName)"
          }
        }
        
        Write-Host "Completed Windows SDK version updates." 
    # Comprehensive Platform Toolset Fix - Update all project files to use v143 (VS2022)
    - name: Fix All Platform Toolsets
      shell: powershell
      run: |
        Write-Host "Updating Platform Toolsets in all project files..."
        
        # Find all .vcxproj files that might have old toolset versions
        $projectFiles = Get-ChildItem -Path "node_modules" -Filter "*.vcxproj" -Recurse -ErrorAction SilentlyContinue
        $projectFiles += Get-ChildItem -Path "windows" -Filter "*.vcxproj" -Recurse -ErrorAction SilentlyContinue
        
        foreach ($projFile in $projectFiles) {
          Write-Host "Checking project file: $($projFile.FullName)"
          
          # Read the content
          $content = Get-Content $projFile.FullName -Raw
          $originalContent = $content
          
          # Replace various old Platform Toolset versions with v143 (Visual Studio 2022)
          $content = $content -replace '<PlatformToolset>v140</PlatformToolset>', '<PlatformToolset>v143</PlatformToolset>'
          $content = $content -replace '<PlatformToolset>v141</PlatformToolset>', '<PlatformToolset>v143</PlatformToolset>'
          $content = $content -replace '<PlatformToolset>v142</PlatformToolset>', '<PlatformToolset>v143</PlatformToolset>'
          
          # Write back if changed
          if ($content -ne $originalContent) {
            Set-Content -Path $projFile.FullName -Value $content
            Write-Host "Updated Platform Toolset in: $($projFile.FullName)"
          }
        }
        
        Write-Host "Completed Platform Toolset updates."     # Install CppWinRT NuGet Package Globally
        # This is a workaround to fix the build error:
        # The "CppWinRT.props" file cannot be found.
        # The "CppWinRT.targets" file cannot be found.
        # The "CppWinRT.props" file cannot be found.
        # It was caused by react-native-sqlite-storage not being able to find the CppWinRT package.
        # The fix is to install the CppWinRT NuGet package globally and then update the SQLitePlugin project file to use the global path.
        - name: Install CppWinRT NuGet Package Globally
          run: |
            # PowerShell commands here
            Write-Host "Installing CppWinRT NuGet Package..."
          shell: pwsh

        - name: Update SQLitePlugin packages.config
          run: |
            # PowerShell commands here
            Write-Host "Updating SQLitePlugin packages.config..."
          shell: pwsh

        # Create self-signed certificate for development/internal use
        - name: Create Self-Signed Certificate
          shell: powershell
          run: |
            $cert = New-SelfSignedCertificate -Subject "CN=YourCompany" -Type CodeSigning -KeyUsage DigitalSignature -FriendlyName "YourApp Code Signing" -CertStoreLocation "Cert:\CurrentUser\My" -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.3", "2.5.29.19={text}")
            $password = ConvertTo-SecureString -String "TempPassword123!" -Force -AsPlainText
            $path = "windows\codesign.pfx"
            Export-PfxCertificate -Cert "Cert:\CurrentUser\My\$($cert.Thumbprint)" -FilePath $path -Password $password
            Write-Host "Certificate created and exported to $path"

        # Build Windows MSIX Package
        - name: Build Windows MSIX Package
          shell: powershell
          run: |
            # First build the solution normally
            Write-Host "Building React Native Windows solution..."
            npx react-native run-windows --no-launch --no-deploy --release
            
            # Now create the MSIX package using MSBuild
            Write-Host "Creating MSIX package..."
            $msbuildPath = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\MSBuild.exe"
            if (-not (Test-Path $msbuildPath)) {
              $msbuildPath = "${env:ProgramFiles}\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\MSBuild.exe"
            }
            if (-not (Test-Path $msbuildPath)) {
              Write-Error "MSBuild not found at expected paths"
              exit 1
            }
            
            # Build with package creation enabled
            & $msbuildPath windows\loadmaster.sln /p:Configuration=Release /p:Platform=x64 /p:AppxBundle=Always /p:AppxBundlePlatforms=x64 /p:PackageCertificateKeyFile=..\codesign.pfx /p:PackageCertificatePassword=TempPassword123! /p:UapAppxPackageBuildMode=StoreUpload

        # Sign the package (if not already signed during build)
        - name: Sign Windows Package
          shell: powershell
          run: |
            # Look for MSIX files in various possible locations
            $searchPaths = @(
              "windows\AppPackages\*\*",
              "windows\loadmaster\AppPackages\*\*", 
              "windows\loadmaster\bin\x64\Release\*",
              "windows\bin\x64\Release\*"
            )
            
            $packagePath = $null
            foreach ($searchPath in $searchPaths) {
              Write-Host "Searching in: $searchPath"
              $found = Get-ChildItem -Path $searchPath -Filter "*.msix" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($found) {
                $packagePath = $found
                break
              }
            }
            
            if ($packagePath) {
              Write-Host "Found package to sign: $($packagePath.FullName)"
              # Check if already signed
              $signResult = & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x64\signtool.exe" verify /pa $packagePath.FullName 2>&1
              if ($LASTEXITCODE -eq 0) {
                Write-Host "Package is already signed"
              } else {
                Write-Host "Signing package..."
                & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x64\signtool.exe" sign /f "windows\codesign.pfx" /p "TempPassword123!" /tr http://timestamp.digicert.com /td sha256 /fd sha256 $packagePath.FullName
                Write-Host "Package signed successfully"
              }
            } else {
              Write-Host "No .msix package found. Listing all build outputs:"
              foreach ($searchPath in $searchPaths) {
                if (Test-Path $searchPath) {
                  Write-Host "Contents of $searchPath :"
                  Get-ChildItem -Path $searchPath -Recurse -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.FullName)" }
                }
              }
            }

        # Alternative: Sign with production certificate (uncomment and use with real certificate)
        # - name: Sign Windows Package (Production)
        #   shell: powershell
        #   run: |
        #     # Decode certificate from base64 secret
        #     $certBytes = [System.Convert]::FromBase64String("${{ secrets.WINDOWS_CERTIFICATE_BASE64 }}")
        #     $certPath = "windows\production-cert.pfx"
        #     [System.IO.File]::WriteAllBytes($certPath, $certBytes)
        #     
        #     $packagePath = Get-ChildItem -Path "windows\AppPackages\*\*" -Filter "*.msix" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
        #     if ($packagePath) {
        #       Write-Host "Signing package with production certificate: $($packagePath.FullName)"
        #       & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x64\signtool.exe" sign /f $certPath /p "${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}" /tr http://timestamp.digicert.com /td sha256 /fd sha256 $packagePath.FullName
        #       Write-Host "Package signed with production certificate"
        #     }     # List contents of relevant directories to find build artifacts
        - name: List build output directories
          shell: powershell
          run: |
            Write-Host "Listing contents of D:\a\loadmaster\loadmaster\windows\loadmaster\AppPackages:"
            dir D:\a\loadmaster\loadmaster\windows\loadmaster\AppPackages -Recurse
            Write-Host "Listing contents of D:\a\loadmaster\loadmaster\windows\AppPackages:"
            dir D:\a\loadmaster\loadmaster\windows\AppPackages -Recurse
            Write-Host "Listing contents of D:\a\loadmaster\loadmaster\windows\loadmaster:"
            dir D:\a\loadmaster\loadmaster\windows\loadmaster -Recurse

        - name: Upload Windows build artifact
          uses: actions/upload-artifact@main
          with:
            name: windows-tablet-build
            path: windows/AppPackages/loadmaster/**/*_Test/**/*

