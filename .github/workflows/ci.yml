name: Build and Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test-ios:
    runs-on: macos-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Cache CocoaPods
      uses: actions/cache@v3
      with:
        path: ios/Pods
        key: ${{ runner.os }}-pods-${{ hashFiles('**/Podfile.lock') }}
        restore-keys: |
          ${{ runner.os }}-pods-
      
    - name: Cache Xcode build
      uses: actions/cache@v3
      with:
        path: ios/build
        key: ${{ runner.os }}-xcode-build-${{ hashFiles('ios/**/*.pbxproj') }}-${{ hashFiles('ios/**/*.swift') }}-${{ hashFiles('ios/**/*.m') }}
        restore-keys: |
          ${{ runner.os }}-xcode-build-
          ${{ runner.os }}-xcode-build-${{ hashFiles('ios/**/*.pbxproj') }}-${{ hashFiles('ios/**/*.swift') }}
      
    - name: Run linter
      run: npm run lint
      
    - name: Run tests
      run: npm test
      
    - name: Install Pod dependencies
      run: |
        cd ios
        pod install
  
    # Build for iPad with landscape orientation
    - name: Build iOS for iPad
      run: |
        xcodebuild -workspace ios/loadmaster.xcworkspace -scheme loadmaster -configuration Release -destination 'platform=iOS Simulator,name=iPad (10th generation)' -derivedDataPath ios/build
    
    - name: Upload iOS build artifact
      uses: actions/upload-artifact@main
      with:
        name: ios-ipad-build
        path: ios/build/Build/Products/Release-iphonesimulator/*.app
        
  build-and-test-windows:
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Install RNW Windows Build Dependencies
      shell: powershell
      run: |
        Set-ExecutionPolicy Unrestricted -Scope Process -Force
        Invoke-WebRequest -UseBasicParsing -Uri 'https://aka.ms/rnw-vs2022-deps.ps1' -OutFile rnw-deps.ps1
        .\\rnw-deps.ps1 -Install -NoPrompt

    - name: Cache Windows build
      uses: actions/cache@v3
      with:
        path: windows/build
        key: ${{ runner.os }}-windows-build-${{ hashFiles('windows/**/*.sln') }}-${{ hashFiles('windows/**/*.cs') }}-${{ hashFiles('windows/**/*.cpp') }}
        restore-keys: |
          ${{ runner.os }}-windows-build-
      
    - name: Run linter
      run: npm run lint
      
    - name: Run tests
      run: npm test
      
    - name: Install react-native-windows
      run: npm install --save-dev react-native-windows@latest

    # Ensure Windows project is properly initialized
    - name: Initialize Windows Project
      shell: powershell
      run: |
        Write-Host "üîß Checking Windows project initialization..." -ForegroundColor Cyan
        
        if (-not (Test-Path "windows\loadmaster.sln")) {
          Write-Host "‚ö†Ô∏è Windows project not found, initializing..." -ForegroundColor Yellow
          npx react-native-windows-init --overwrite
          Write-Host "‚úÖ Windows project initialized" -ForegroundColor Green
        } else {
          Write-Host "‚úÖ Windows project already exists" -ForegroundColor Green
        }
        
        Write-Host "Windows project structure:"
        Get-ChildItem -Path "windows" -Directory | ForEach-Object {
          Write-Host "  üìÅ $($_.Name)" -ForegroundColor Gray
        }
        
        # Check solution file and project configuration
        if (Test-Path "windows\loadmaster.sln") {
          Write-Host "`nüîç Solution file analysis:" -ForegroundColor Cyan
          $SolutionContent = Get-Content "windows\loadmaster.sln"
          
          # Extract project configurations
          $SolutionContent | Where-Object { $_ -match "GlobalSection\(SolutionConfigurationPlatforms\)" -or $_ -match "Release\|" -or $_ -match "Debug\|" } | ForEach-Object {
            if ($_ -match "(Release|Debug)\|(.+) = ") {
              Write-Host "  üìã Config: $($matches[1])|$($matches[2])" -ForegroundColor Gray
            }
          }
          
          # Find the main project file
          $ProjectLine = $SolutionContent | Where-Object { $_ -match "loadmaster.*\.vcxproj" }
          if ($ProjectLine) {
            Write-Host "  üéØ Main project: $($ProjectLine -replace '.*"([^"]+\.vcxproj)".*', '$1')" -ForegroundColor Gray
          }
        }
        
        # Check if we have the right build tools
        Write-Host "`nüîß Build tools check:" -ForegroundColor Cyan
        try {
          $MSBuildVersion = & msbuild -version 2>&1 | Select-Object -First 1
          Write-Host "  ‚úÖ MSBuild: $MSBuildVersion" -ForegroundColor Green
        } catch {
          Write-Host "  ‚ùå MSBuild not found" -ForegroundColor Red
        }
        
        # Ensure NuGet packages are restored
        Write-Host "`nüì¶ Restoring NuGet packages..." -ForegroundColor Cyan
        if (Test-Path "windows\loadmaster.sln") {
          try {
            nuget restore windows\loadmaster.sln
            Write-Host "  ‚úÖ NuGet restore completed" -ForegroundColor Green
          } catch {
            Write-Host "  ‚ö†Ô∏è NuGet restore failed: $_" -ForegroundColor Yellow
          }
        }

    # Update the Platform Toolset for SQLitePlugin to v143 (Visual Studio 2022)
    - name: Update SQLitePlugin Platform Toolset
      shell: powershell
      run: |
        $projFile = "node_modules\\react-native-sqlite-storage\\platforms\\windows\\SQLitePlugin\\SQLitePlugin.vcxproj"
        if (Test-Path $projFile) {
          (Get-Content $projFile) -replace '<PlatformToolset>v140</PlatformToolset>','<PlatformToolset>v143</PlatformToolset>' -replace '<PlatformToolset>v141</PlatformToolset>','<PlatformToolset>v143</PlatformToolset>' | Set-Content $projFile
          Write-Host "Updated Platform Toolset in SQLitePlugin.vcxproj to v143"
        } else {
          Write-Error "SQLitePlugin.vcxproj not found at expected path"
          exit 1
        }

    # Update the Windows SDK version for SQLitePlugin to one available in the CI environment
    - name: Update SQLite Windows SDK Version
      shell: powershell
      run: |
        $projFile = "node_modules\\react-native-sqlite-storage\\platforms\\windows\\SQLitePlugin\\SQLitePlugin.vcxproj"
        if (Test-Path $projFile) {
          (Get-Content $projFile) -replace '10.0.18362.0','10.0.19041.0' -replace '10.0.16299.0','10.0.19041.0' | Set-Content $projFile
          Write-Host "Updated SQLite Windows SDK version in SQLitePlugin.vcxproj to 10.0.19041.0"
        } else {
          Write-Error "SQLitePlugin.vcxproj not found at expected path"
          exit 1
        }

    # Create JavaScript bundle before building
    - name: Create JavaScript Bundle
      shell: powershell
      run: |
        Write-Host "üì¶ Preparing JavaScript bundle..." -ForegroundColor Cyan
        
        # Ensure Bundle directory exists
        $BundleDir = "windows\loadmaster\Bundle"
        if (-not (Test-Path $BundleDir)) {
          New-Item -ItemType Directory -Path $BundleDir -Force | Out-Null
          Write-Host "‚úÖ Created Bundle directory" -ForegroundColor Green
        }
        
        # Create the bundle
        $BundleFile = "$BundleDir\index.windows.bundle"
        Write-Host "üèóÔ∏è Creating bundle: $BundleFile" -ForegroundColor Yellow
        
        try {
          npx react-native bundle --platform windows --entry-file index.js --bundle-output $BundleFile --assets-dest $BundleDir --dev false
          
          if (Test-Path $BundleFile) {
            $BundleSize = [Math]::Round((Get-Item $BundleFile).Length / 1KB, 2)
            Write-Host "‚úÖ Bundle created: $BundleSize KB" -ForegroundColor Green
          } else {
            Write-Host "‚ö†Ô∏è Bundle file not found after creation" -ForegroundColor Yellow
          }
        } catch {
          Write-Host "‚ùå Bundle creation failed: $_" -ForegroundColor Red
          Write-Host "‚ö†Ô∏è Continuing with build - bundle will be created during build process" -ForegroundColor Yellow
        }

    # Install CppWinRT NuGet Package Globally
    # This is a workaround to fix the build error:
    # The "CppWinRT.props" file cannot be found.
    # The "CppWinRT.targets" file cannot be found.
    # The "CppWinRT.props" file cannot be found.
    # It was caused by react-native-sqlite-storage not being able to find the CppWinRT package.
    # The fix is to install the CppWinRT NuGet package globally and then update the SQLitePlugin project file to use the global path.
    - name: Install CppWinRT NuGet Package Globally
      shell: powershell
      run: |
        nuget install Microsoft.Windows.CppWinRT -Version 2.0.230706.1 -OutputDirectory C:\\NuGetPackages
        Write-Host "Installed CppWinRT 2.0.230706.1 to C:\\NuGetPackages"
        Write-Host "Contents of C:\\NuGetPackages:"
        Get-ChildItem -Path "C:\\NuGetPackages" -Recurse | Where-Object { $_.FullName -like "*CppWinRT*" } | ForEach-Object { Write-Host $_.FullName }

    - name: Update SQLitePlugin packages.config
      shell: powershell
      run: |
        $packagesConfig = "node_modules\\react-native-sqlite-storage\\platforms\\windows\\SQLitePlugin\\packages.config"
        if (Test-Path $packagesConfig) {
          # Update CppWinRT version to match what's being installed
          (Get-Content $packagesConfig) -replace 'version="2.0.200615.7"', 'version="2.0.230706.1"' | Set-Content $packagesConfig
          Write-Host "Updated CppWinRT version in packages.config to 2.0.230706.1"
          Write-Host "Contents of packages.config:"
          Get-Content $packagesConfig
        } else {
          Write-Error "packages.config not found at expected path"
          exit 1
        }

    - name: Fix SQLitePlugin Project To Use Global Packages
      shell: powershell
      run: |
        $projFile = "node_modules\\react-native-sqlite-storage\\platforms\\windows\\SQLitePlugin\\SQLitePlugin.vcxproj"
        if (Test-Path $projFile) {
          # Update the package reference to use the global path with forward slashes
          $content = Get-Content $projFile
          # 1. Update the props import
          $content = $content -replace '<Import Project="\$\(SolutionDir\)\\packages\\Microsoft\.Windows\.CppWinRT\.2\.0\.[0-9.]+\\build\\native\\Microsoft\.Windows\.CppWinRT\.props"', '<Import Project="C:/NuGetPackages/Microsoft.Windows.CppWinRT.2.0.230706.1/build/native/Microsoft.Windows.CppWinRT.props"'
          # 2. Update the targets import
          $content = $content -replace '<Import Project="\$\(SolutionDir\)\\packages\\Microsoft\.Windows\.CppWinRT\.2\.0\.[0-9.]+\\build\\native\\Microsoft\.Windows\.CppWinRT\.targets"', '<Import Project="C:/NuGetPackages/Microsoft.Windows.CppWinRT.2.0.230706.1/build/native/Microsoft.Windows.CppWinRT.targets"'
          # 3. Update the error conditions
          $content = $content -replace '!Exists\(''\$\(SolutionDir\)\\packages\\Microsoft\.Windows\.CppWinRT\.2\.0\.[0-9.]+\\build\\native\\Microsoft\.Windows\.CppWinRT\.props''\)', '!Exists(''C:/NuGetPackages/Microsoft.Windows.CppWinRT.2.0.230706.1/build/native/Microsoft.Windows.CppWinRT.props'')'
          $content = $content -replace '!Exists\(''\$\(SolutionDir\)\\packages\\Microsoft\.Windows\.CppWinRT\.2\.0\.[0-9.]+\\build\\native\\Microsoft\.Windows\.CppWinRT\.targets''\)', '!Exists(''C:/NuGetPackages/Microsoft.Windows.CppWinRT.2.0.230706.1/build/native/Microsoft.Windows.CppWinRT.targets'')'
          # 4. Update error messages
          $content = $content -replace '\$\(\[System\.String\]::Format\(''\$\(ErrorText\)'', ''\$\(SolutionDir\)\\packages\\Microsoft\.Windows\.CppWinRT\.2\.0\.[0-9.]+\\build\\native\\Microsoft\.Windows\.CppWinRT\.props''\)\)', '$([System.String]::Format(''$(ErrorText)'', ''C:/NuGetPackages/Microsoft.Windows.CppWinRT.2.0.230706.1/build/native/Microsoft.Windows.CppWinRT.props''))'
          $content = $content -replace '\$\(\[System\.String\]::Format\(''\$\(ErrorText\)'', ''\$\(SolutionDir\)\\packages\\Microsoft\.Windows\.CppWinRT\.2\.0\.[0-9.]+\\build\\native\\Microsoft\.Windows\.CppWinRT\.targets''\)\)', '$([System.String]::Format(''$(ErrorText)'', ''C:/NuGetPackages/Microsoft.Windows.CppWinRT.2.0.230706.1/build/native/Microsoft.Windows.CppWinRT.targets''))'
          Set-Content $projFile $content
          Write-Host "Updated SQLitePlugin.vcxproj to use global CppWinRT package path"
          Write-Host "Checking for C:/NuGetPackages/Microsoft.Windows.CppWinRT.2.0.230706.1/build/native/Microsoft.Windows.CppWinRT.props"
          if (Test-Path "C:/NuGetPackages/Microsoft.Windows.CppWinRT.2.0.230706.1/build/native/Microsoft.Windows.CppWinRT.props") {
            Write-Host "FOUND: CppWinRT.props exists"
          } else {
            Write-Host "MISSING: CppWinRT.props not found"
          }
        } else {
          Write-Error "SQLitePlugin.vcxproj not found at expected path"
          exit 1
        }

    - name: Build Windows
      shell: powershell
      run: |
        Write-Host "üèóÔ∏è Building Windows Release..." -ForegroundColor Cyan
        
        # First, try the standard React Native way
        Write-Host "üìã Attempting React Native build..." -ForegroundColor Yellow
        try {
          npx react-native run-windows --no-launch --no-deploy --release --logging --no-packager
          Write-Host "‚úÖ React Native build completed" -ForegroundColor Green
        } catch {
          Write-Host "‚ö†Ô∏è React Native build failed, trying MSBuild directly..." -ForegroundColor Yellow
        }
        
        # If that didn't work or didn't create an exe, try MSBuild directly
        $ExePath = "windows\loadmaster\x64\Release\loadmaster.exe"
        if (-not (Test-Path $ExePath)) {
          Write-Host "üî® Building with MSBuild directly..." -ForegroundColor Cyan
          
          if (Test-Path "windows\loadmaster.sln") {
            try {
              # Use MSBuild directly
              msbuild windows\loadmaster.sln /p:Configuration=Release /p:Platform=x64 /p:AppxBundle=Never /m
              Write-Host "‚úÖ MSBuild completed" -ForegroundColor Green
            } catch {
              Write-Host "‚ùå MSBuild failed: $_" -ForegroundColor Red
              
              # Try with different platform
              Write-Host "üîÑ Trying with Win32 platform..." -ForegroundColor Yellow
              try {
                msbuild windows\loadmaster.sln /p:Configuration=Release /p:Platform=Win32 /p:AppxBundle=Never /m
                Write-Host "‚úÖ MSBuild Win32 completed" -ForegroundColor Green
              } catch {
                Write-Host "‚ùå MSBuild Win32 also failed: $_" -ForegroundColor Red
              }
            }
          } else {
            Write-Host "‚ùå No solution file found!" -ForegroundColor Red
          }
        }
        
        # Check if exe was actually created
        $ExePath = "windows\loadmaster\x64\Release\loadmaster.exe"
        $ExePathWin32 = "windows\loadmaster\Release\loadmaster.exe"
        $ExePathAlt = "windows\loadmaster\AppPackages\loadmaster\loadmaster.exe"
        
        $FoundExe = $null
        @($ExePath, $ExePathWin32, $ExePathAlt) | ForEach-Object {
          if (Test-Path $_) {
            $FoundExe = $_
            Write-Host "‚úÖ Found exe: $_" -ForegroundColor Green
            $ExeSize = [Math]::Round((Get-Item $_).Length / 1MB, 2)
            Write-Host "   Size: $ExeSize MB" -ForegroundColor Gray
          }
        }
        
        if (-not $FoundExe) {
          Write-Host "‚ùå No exe found in expected locations" -ForegroundColor Red
          Write-Host "üîç Searching for exe files in entire windows folder..." -ForegroundColor Yellow
          Get-ChildItem -Path "windows" -Recurse -Filter "*.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "  Found exe: $($_.FullName)" -ForegroundColor Yellow
          }
          
          Write-Host "üîç Checking all build output folders..." -ForegroundColor Yellow
          @("Debug", "Release", "x64", "x86", "Win32", "ARM", "ARM64") | ForEach-Object {
            $SearchPath = "windows\**\$_"
            Get-ChildItem -Path "windows" -Recurse -Directory -Filter $_ -ErrorAction SilentlyContinue | ForEach-Object {
              Write-Host "  üìÅ Found build folder: $($_.FullName)" -ForegroundColor Gray
              Get-ChildItem -Path $_.FullName -Recurse -Filter "*.exe" -ErrorAction SilentlyContinue | ForEach-Object {
                Write-Host "    üéØ EXE: $($_.FullName)" -ForegroundColor Green
              }
            }
          }
          
          # Show what IS in the main folders
          Write-Host "üîç Contents of key folders:" -ForegroundColor Yellow
          @("windows\loadmaster\x64\Release", "windows\loadmaster\Release", "windows\loadmaster\AppPackages") | ForEach-Object {
            if (Test-Path $_) {
              Write-Host "  üìÅ $_" -ForegroundColor Gray
              Get-ChildItem -Path $_ -ErrorAction SilentlyContinue | ForEach-Object {
                Write-Host "    - $($_.Name)" -ForegroundColor Gray
              }
            }
          }
        }
        
        # Extract exe from MSIX package if build succeeded
        Write-Host "`nüì¶ Checking for MSIX packages..." -ForegroundColor Cyan
        $MSIXPackages = Get-ChildItem -Path "windows\AppPackages" -Recurse -Filter "*.msix" -ErrorAction SilentlyContinue
        if ($MSIXPackages) {
          Write-Host "‚úÖ Found MSIX packages:" -ForegroundColor Green
          $MSIXPackages | ForEach-Object {
            Write-Host "  üì¶ $($_.FullName)" -ForegroundColor Gray
          }
          
          # Extract exe from the first MSIX package
          $FirstMSIX = $MSIXPackages[0]
          Write-Host "`nüîì Extracting exe from MSIX package..." -ForegroundColor Yellow
          
          $ExtractDir = "windows\extracted_msix"
          if (Test-Path $ExtractDir) {
            Remove-Item -Path $ExtractDir -Recurse -Force
          }
          New-Item -ItemType Directory -Path $ExtractDir -Force | Out-Null
          
          try {
            # MSIX is essentially a ZIP file, so we can extract it
            Add-Type -AssemblyName System.IO.Compression.FileSystem
            [System.IO.Compression.ZipFile]::ExtractToDirectory($FirstMSIX.FullName, $ExtractDir)
            
            # Find the exe in the extracted content
            $ExtractedExe = Get-ChildItem -Path $ExtractDir -Recurse -Filter "*.exe" | Where-Object { $_.Name -ne "app.exe" -and $_.Name -like "*loadmaster*" }
            if (-not $ExtractedExe) {
              # Sometimes it's just called app.exe
              $ExtractedExe = Get-ChildItem -Path $ExtractDir -Recurse -Filter "app.exe"
            }
            
            if ($ExtractedExe) {
              # Copy exe and its dependencies to a Release-like folder
              $DevReleaseDir = "windows\dev_release"
              if (Test-Path $DevReleaseDir) {
                Remove-Item -Path $DevReleaseDir -Recurse -Force
              }
              New-Item -ItemType Directory -Path $DevReleaseDir -Force | Out-Null
              
              # Copy the exe
              Copy-Item -Path $ExtractedExe.FullName -Destination "$DevReleaseDir\loadmaster.exe"
              
              # Copy all DLLs from the same directory
              $ExeDir = $ExtractedExe.DirectoryName
              Get-ChildItem -Path $ExeDir -Filter "*.dll" | ForEach-Object {
                Copy-Item -Path $_.FullName -Destination $DevReleaseDir
              }
              
              # Copy any other important files
              @("*.pri", "*.config", "*.manifest") | ForEach-Object {
                Get-ChildItem -Path $ExeDir -Filter $_ | ForEach-Object {
                  Copy-Item -Path $_.FullName -Destination $DevReleaseDir
                }
              }
              
              Write-Host "‚úÖ Extracted exe and dependencies to: $DevReleaseDir" -ForegroundColor Green
              Write-Host "   Main exe: $DevReleaseDir\loadmaster.exe" -ForegroundColor Gray
              
              $DllCount = (Get-ChildItem -Path $DevReleaseDir -Filter "*.dll").Count
              Write-Host "   Dependencies: $DllCount DLLs" -ForegroundColor Gray
              
            } else {
              Write-Host "‚ùå No exe found in MSIX package" -ForegroundColor Red
              Write-Host "Contents of MSIX:" -ForegroundColor Yellow
              Get-ChildItem -Path $ExtractDir -Recurse | ForEach-Object {
                Write-Host "  - $($_.FullName.Replace($ExtractDir, ''))" -ForegroundColor Gray
              }
            }
          } catch {
            Write-Host "‚ùå Failed to extract MSIX: $_" -ForegroundColor Red
          }
        } else {
          Write-Host "‚ùå No MSIX packages found" -ForegroundColor Red
        }

    # List contents of relevant directories to find build artifacts
    - name: List build output directories
      shell: powershell
      run: |
        Write-Host "=== Build Summary ===" -ForegroundColor Cyan
        
        Write-Host "`nüì¶ MSIX Packages:" -ForegroundColor Yellow
        Get-ChildItem -Path "windows\AppPackages" -Recurse -Filter "*.msix" -ErrorAction SilentlyContinue | ForEach-Object {
          $size = [Math]::Round($_.Length / 1MB, 2)
          Write-Host "  - $($_.Name) ($size MB)" -ForegroundColor Green
        }
        
        Write-Host "`nüéØ Extracted Dev Files:" -ForegroundColor Yellow
        if (Test-Path "windows\dev_release") {
          Get-ChildItem -Path "windows\dev_release" -ErrorAction SilentlyContinue | ForEach-Object {
            $size = [Math]::Round($_.Length / 1KB, 2)
            Write-Host "  - $($_.Name) ($size KB)" -ForegroundColor Green
          }
        } else {
          Write-Host "  - No dev release folder found" -ForegroundColor Gray
        }
        
        Write-Host "`nüìÑ Bundle Files:" -ForegroundColor Yellow
        if (Test-Path "windows\loadmaster\Bundle") {
          Get-ChildItem -Path "windows\loadmaster\Bundle" -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
            $relativePath = $_.FullName.Replace("$PWD\windows\loadmaster\Bundle\", "")
            Write-Host "  - $relativePath" -ForegroundColor Green
          }
        } else {
          Write-Host "  - No Bundle folder found" -ForegroundColor Gray
        }

    - name: Upload Windows exe for development
      uses: actions/upload-artifact@main
      with:
        name: windows-dev-exe
        path: |
          windows/dev_release/**/*
          windows/loadmaster/Bundle/**/*
          windows/AppPackages/**/*.msix

    - name: Upload Windows build artifact
      uses: actions/upload-artifact@main
      with:
        name: windows-tablet-build
        path: windows/AppPackages/loadmaster/**/*

